
var _ = require('dry-underscore');

function db_class(collections, options){
    
    options = options || {};
    collections = collections || {};


    this._host = options.host || "127.0.0.1";
    this._port = options.port || "27017";
    this._name = options.name || "default";
    this._collections = collections;
    this._url = "mongodb://" + this._host + ":" + this._port + "/" + this._name;

    this._client = require('mongodb').MongoClient;

    this._collections = {};

    this.outgoing_processor = function(f){ this.process_outgoing = _.compose(this.process_outgoing, f); };
    this.incoming_processor = function(f){ this.process_incoming = _.compose(this.process_incoming, f); };

    this.process_outgoing = function(records){ return(records); };
    this.process_incoming = function(records){ return(records); };
 
    this._add_colletions(collections);
}

db_class.prototype.collections = _.r("_collections");

db_class.prototype._add_colletions = function(collections){
    var self = this;

    _.each(collections, function(collection, collection_name){
        if(self[collection_name]){ _.fatal("Can not use: " + collection_name + " as a collection name."); }
        self._collections[collection_name] = collection;
        self[collection_name] = new collection_class(self, collection_name);
    });
};

db_class.prototype.open = function(callback){
    this._client.connect(this._url, callback); 
};

db_class.prototype.collection = function(collection_name, callback){
    await{ this.open(_.plumb(defer(var db), callback)); }
    var collection = db.collection(collection_name);
    collection.close = function(){ db.close(); };
    callback(null, collection);
};

db_class.prototype.drop_collection = function(collection_name, callback){

    await{ this.open(_.plumb(defer(var db), callback)); }
    db.dropCollection(collection_name, function(){
        db.close();
        return callback.apply(null, arguments);
    });
};

function collection_class(db, name){
    this._db = db;
    this._name = name || "default";

    this.outgoing_processor = function(f){ this.process_outgoing = _.compose(this.process_outgoing, f); };
    this.incoming_processor = function(f){ this.process_incoming = _.compose(this.process_incoming, f); };

    this.process_outgoing = function(records){ return(db.process_outgoing(records)); };
    this.process_incoming = function(records){ return(db.process_incoming(records)); };
}

collection_class.prototype.update = function(query, update, options, callback){

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }

    options.fullResult = true;

    await{ this._db.collection(this._name, _.plumb(defer(var collection), callback)); }

    collection.update(query, update, options, function(){
        collection.close();
        return callback.apply(null, arguments);
    }); 
};

collection_class.prototype.update_one = function(query, update, options, callback){
    var self = this;

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }
    
    var sort = options.sort || null;

    await{ self._db.collection(self._name, _.plumb(defer(var collection), callback)); }

    collection.findAndModify(query, sort, update, options, function(err, doc, results){
        collection.close();
        if(err){ return callback(err); }
        else{ 
            if(doc){ results.n = 1; }
            else{ results.n = 0; }
            return callback(null, doc ? self.process_outgoing(doc) : null, results);
        }
    }); 
};
 
 
collection_class.prototype.insert = function(docs, options, callback){

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }

    options.fullResult = true;

    await{ this._db.collection(this._name, _.plumb(defer(var collection), callback)); }

    if(_.isArray(docs)){ docs = _.map(docs, this.process_incoming); }
    else{ docs = this.process_incoming(docs); }

    collection.insert(docs, options, function(err, results){
        results.n = results.nInserted;
        collection.close();
        return callback.apply(null, arguments);
    }); 
};

collection_class.prototype.remove = function(query, options, callback){

    if(_.isFunction(query)){
        callback = query;
        query = {};
        options = {};
    }

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }

    options.fullResult = true;

    await{ this._db.collection(this._name, _.plumb(defer(var collection), callback)); }

    collection.remove(query, options, function(){
        collection.close();
        return callback.apply(null, arguments);
    }); 
};


collection_class.prototype.cursor = function(query, options, callback){

    var self = this;

    if(_.isFunction(query)){
        callback = query;
        query = {};
        options = {};
    }

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }

    await{ self._db.collection(this._name, _.plumb(defer(var collection), callback)); }

    var cursor = collection.find(query, options);

    cursor.done = function(){ collection.close(); };

    cursor.rawNextObject = cursor.nextObject;
    
    cursor.nextObject = function(opt, cb){
        if(_.isFunction(opt)){
            cb = opt;
            opt = {};
        }
        return cursor.rawNextObject(opt, function(err, doc){
            if(err){ return cb(err); }
            else if(doc){ return cb(err, self.process_outgoing(doc)); }
            else{ return cb(err, null); }
        });
    };

    cursor.rawToArray = cursor.toArray;

    cursor.toArray = function(cb){
        return cursor.rawToArray(function(err, docs){
            if(err){ return cb(err); }
            else{ return cb(err, _.map(docs, self.process_outgoing)); }
        });
    };

    return callback(null, cursor);
};

collection_class.prototype.find = function(query, options, callback){

    if(_.isFunction(query)){
        callback = query;
        query = {};
        options = {};
    }

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }

    this.cursor(query, options, _.plumb(function(cursor){
        cursor.toArray(function(){
            cursor.done();
            return callback.apply(null, arguments);
        });
    }, callback));
};

collection_class.prototype.find_index = function(query, options, callback, field){
    if(_.isFunction(query)){
        callback = query;
        field = options;
        query = {};
        options = {};
    }

    if(_.isFunction(options)){
        field = callback;
        callback = options;
        options = {};
    }

    if(!field){ field = "id"; }

    await{ this.find(query, options, _.plumb(defer(var records), callback)); }

    return callback(null, _.indexBy(records, field));
};

collection_class.prototype.find_group = function(query, options, callback, field){
    if(_.isFunction(query)){
        callback = query;
        field = options;
        query = {};
        options = {};
    }

    if(_.isFunction(options)){
        field = callback;
        callback = options;
        options = {};
    }

    if(!field){ field = "id"; }

    await{ this.find(query, options, _.plumb(defer(var records), callback)); }

    return callback(null, _.groupBy(records, field));
};

collection_class.prototype.find_one = function(query, options, callback){

    if(_.isFunction(query)){
        callback = query;
        query = {};
        options = {};
    }

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }

    this.cursor(query, _.extend(options, { limit: 1 }), _.plumb(function(cursor){
        cursor.toArray(function(err, docs){
            cursor.done();
            if(err){ return callback(err); }
            else if(docs.length){ return callback(null, docs[0]); }
            else{ return callback(null, null); }
        });
    }, callback));
};
 
collection_class.prototype.count = function(query, options, callback){

    if(_.isFunction(query)){
        callback = query;
        query = {};
        options = {};
    }

    if(_.isFunction(options)){
        callback = options;
        options = {};
    }

    await{ this._db.collection(this._name, _.plumb(defer(var collection), callback)); }

    collection.count(query, options, function(){
        collection.close();
        return callback.apply(null, arguments);
    }); 
};

collection_class.prototype.index = function(index, callback){

    await{ this._db.collection(this._name, _.plumb(defer(var collection), callback)); }

    collection.ensureIndex(index, function(){
        collection.close();
        return callback.apply(null, arguments);
    });
};


module.exports = db_class;
